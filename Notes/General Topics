--- Don't want to make an Object of a Class?
- make it's contructor private.
But can we achieve this by making the class as an abstract class?
- Making the class an abstract can prevent creating the object of that abstract class, but it will forward this reponsibility to the sub-classes.
- making the constructor of a class as private will strictly prevent the object creation. object of that class or it's subclasses cannot be created.--
-- where to use this feature?
    public class MathUtils {
        private MathUtils() {} // Prevent instantiation
    
        public static int square(int num) {
            return num * num;
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            // MathUtils obj = new MathUtils(); // ❌ Not allowed
            System.out.println(MathUtils.square(5)); // ✅ Prints: 25
        }
    }
Best real case is in the System & Math classes where the System construtor is Privatized.

--- StringBuffers will have a capacity of 16 at the start. after that they will keep an extra continuous space of 16 characters. 
    This is done so that the append and other operations can be done on the same string (array) easily.
    Later on, with increasing size, the size of the buffer (array) is dynamically increased by the JVM.

--- While doing, 
String str1 = "Hello";
String str2 = "World";
String newStr = str1 + str2;
- The '+' operation internally uses StringBuffer for appending.
- The compiler converts the above program to 
    => newStr = new StringBuffer().append(str1).append(str2).toString();
The native append operation is slow (even after using buffer in the back),
since appending multiple strings creats more and more objects of buffer in the back. 
This slows down the performance since many useless buffer objects are created.

--- Does Java use pass by value or pass by reference?
- By default java uses pass by value. 
- If you see something like this: 
    void someMethod(SomeObject obj);
- then we are not passing the reference to that object. 
    Instead, we are passing the location of that object as the value to that function.

---  which classes are immutable in Java
- By default all the Wrapper classes are Immutable in Java.
- List, Sets & Maps are also immutable. Whereas their implementations (ArrayList, LinkedList, etc.) are mutable.
- some other classes like Date & Time classes are also immutable.

--- when to use StringBuffer vs StringBuilder?
- use StringBuffer when you are dealing with multiple threads.
    All the methods of StringBuffer are 'Synchronized'.
    Only one thread can access the method at a time.
    This makes them 'Thread Safe'.
    It also makes the process a bit slow.

- use StringBuilder when dealing with single thread.
    no methods here are 'Synchronized'.
    this makes them very fast compared to buffers.
    Hence, they are not 'Thread Safe'.

--- Interesting Facts.
- switch always works faster with int rather than Strings.
- Before java 7, switch only supported primitives, but now swtch can also intake non primitives.
- for matching a String to a case in Switch Case, the strings in case blocks are converted integers (stored in the form of hashmaps) the values are then compared.

- HashMap internally uses both LinkedList asnd B-tree.
- ArrayList Dynamically increases it's size. The default value is 10. after adding more elements it then creates a new element with 1.5x the original size.
    So adding elements to an ArrayList frequently may cause performance overheads.
- Integer.valueOf(x) caches values between -128 to 127, so repeated calls within this range reuse the same object.
- A try-finally block will always exec. even after the return statement is called.
    eg. try{ return 20; }
        finally { sout("I ran even if your returned statement was called!"); } //This block will be executed.
- Math.abs(Integer.MIN_VALUE) Produces a Negative Number!

- all fields (variables) in interface are public,static and final.

- The main method can also be overloaded. This means that a program can have multiple main methods.
    But the JVM will only choose the default main(String[] args) method. The other overloaded main methods should be called inside this default main method explicitly.
ex.
public class MainOverloadExample {
    psvm(String[] args){
        syso("Standard main method");
        main(10);
        msin("hello");
    }
    psvm(int num){
        syso(num);
    }
    psvm(String msg){
        syso(msg);
    }
}

// if you want to pass function to a function in java use:
Function<Integer, Integer> square = i -> i * i;
System.out.println(square.apply(3));
